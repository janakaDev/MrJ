{"intents": [
	{"tag": "greeting",

         "patterns": ["Hi", "How are you", "Is anyone there?", "Hello", "Good day"],

         "responses": ["Hello, thanks for visiting", "Good to see you again", "Hi there, how can I help?"],

         "context_set": ""

        },

        {"tag": "goodbye",

         "patterns": ["Bye", "See you later", "Goodbye"],

         "responses": ["See you later, thanks for visiting", "Have a nice day", "Bye! Come back again soon."]

        },

        {"tag": "thanks",

         "patterns": ["Thanks", "Thank you", "That's helpful"],

         "responses": ["Happy to help!", "Any time!", "My pleasure"]

        },

        {"tag": "hours",

         "patterns": ["What hours are you open?", "What are your hours?", "When are you open?" ],

         "responses": ["We're open every day 9am-9pm", "Our hours are 9am-9pm every day"]

        },

        {"tag": "mopeds",

         "patterns": ["Which mopeds do you have?", "What kinds of mopeds are there?", "What do you rent?" ],

         "responses": ["We rent Yamaha, Piaggio and Vespa mopeds", "We have Piaggio, Vespa and Yamaha mopeds"]

        },

        {"tag": "payments",

         "patterns": ["Do you take credit cards?", "Do you accept Mastercard?", "Are you cash only?" ],

         "responses": ["We accept VISA, Mastercard and AMEX", "We accept most major credit cards"]

        },

        {"tag": "opentoday",

         "patterns": ["Are you open today?", "When do you open today?", "What are your hours today?"],

         "responses": ["We're open every day from 9am-9pm", "Our hours are 9am-9pm every day"]

        },

        {"tag": "rental",

         "patterns": ["Can we rent a moped?", "I'd like to rent a moped", "How does this work?" ],

         "responses": ["Are you looking to rent today or later this week?"],

         "context_set": "rentalday"

        },

        {"tag": "today",

         "patterns": ["today"],

         "responses": ["For rentals today please call 1-800-MYMOPED", "Same-day rentals please call 1-800-MYMOPED"],

         "context_filter": "rentalday"

        },
	
	{
		"Question": "how to produce PDF files from exercises in Sweave format. Meanwhile, exams has been",
		"Answer": "considerably extended by Zeileis, Umlauf, and Leisch (2014) and beyond to also produce HTML output or e-learning exams for Moodle, OLAT/OpenOLAT, etc. This has resulted in some small changes that are not fully backward-compatible and which are marked with UPDATE in the text below. Package exams provides a framework for automatic generation of standardized statis- tical exams which is especially useful for large-scale exams. To employ the tools, users just need to supply a pool of exercises and a master file controlling the layout of the final PDF document. The exercises are specified in separate Sweave files (containing R code for data generation and LATEX code for problem and solution description) and the master file is a LATEX document with some additional control commands. This paper gives an overview of the main design aims and principles as well as strategies for adaptation and extension. Hands-on illustrations - based on example exercises and control files provided in the package - are presented to get new users started easily. Keywords: exams, multiple choice, arithmetic problems, Sweave, LATEX, R. 1. Introduction The introductory statistics lecture at the Wirtschaftsuniversita¨t Wien (WU Wien, http: //www.wu.ac.at/) is attended each semester by about 1,000-1,500 students (mostly first-year business students). Several lecturers from the Department of Statistics and Mathematics teach this course in parallel. In order to ensure an efficient, consistent, and transparent organization, the course format and all its teaching materials (presentation slides, collections of exercises, exams, etc.) were re-designed in a collaborative effort during 2006/7. Among many other aspects - such as specification of a topic list or definition of learning outcomes, etc. - this re- design encompassed several technological challenges. Hence, the exams package was designed to address these challenges and thus facilitate the discussions about the content of the new course. More specifically, exams aims to provide software infrastructure for: ❼ Scalable exams: Automatic generation of a large number of different exams in order to provide an individual test to each student. ❼ Associated self-study materials: Collections of exercises and solutions from the same pool of examples. 2 Automatic Generation of Exams in R ❼ Joint development: Development and maintenance of a large pool of exercises in a multi-author and cross-platform setting. Specifically, at WU Wien about 10-15 lecturers were working in small teams of 2-4 people on different chapters for the presentation slides. For each chapter, the corresponding team would also provide suitable exercise templates that could be used for self-study materials, exams, and solutions. The pool of exercises does not only need to contain different types of exercises, but also variants of the same type to avoid that students learn the solutions by heart. Correction should be fast and easy. This restricts the suitable types of exercises to those which either have a single number as result which only needs to be checked to assess the correctness, multiple-choice questions, or potentially questions which require only a short text answer. These requirements on maintenance, variation, and correction of exercises led to the following design principles for package exams: ❼ Maintenance: Each exercise template is a single file (also just called exercise). ❼ Variation: Exercises are dynamic documents, containing a problem/solution along with a data-generating process (DGP) so that random samples can be drawn easily. ❼ Correction: Solutions for exercises are either multiple-choice answers (logical vectors), numeric values (e.g., a test statistic or a confidence interval), short text answers (e.g., the appropriate null hypothesis corresponding to a given problem), or combinations of these. Thus, the DGP of an exercise controls the distribution of possible solutions and can be utilized to make them (approximately) evenly distributed and difficult to guess or learn by heart. In addition to the variability within an exercise, one can add further variation by providing several exercise templates for the same type of problem. Depending on the flexibility of the DGP, the pool of exercises can thus be rather small or needs to be somewhat larger. Mixing problems/solutions and DGPs for exam generation poses challenges that are similar to those of making data analysis reproducible. Thus, exams employs many ideas from literate data analysis (Rossini 2001; Leisch and Rossini 2003), literate programming (Knuth 1992) and reproducible research (de Leeuw 2001). Specifically, it makes extensive use of Sweave (Leisch 2002) for mixing DGPs written in the R system for statistical computing (R Development Core Team 2008) and problem/solution descriptions written in the typesetting system LATEX (Knuth 1984; Lamport 1994). Thus, the implementation in exams is based on (1) independent Sweave files for each exercise interweaving R and LATEX code, (2) different master LATEX files controlling the appearance and (3) an implementation of a minimal markup for communication with R plus R functions tying everything together. The package exams that emerged from the developments at WU Wien is available from the Comprehensive R Archive Network at http://CRAN.R-project.org/package=exams. To uti- lize it for exam generation, users need to generate a pool of exercises and supply a master LATEX file. The package provides several examples for both types of files along with docu- mentation (like this paper) and hands-on examples to get new users started.1 Hence, the 1In version 2 of the exams package a new function exams_skeleton() has been added to facilitate starting new exams projects. See Section 2.3 of Zeileis et al. (2014) or vignette(exams2, package = exams) for more details. Bettina Gru¨n, Achim Zeileis 3 remainder of this paper is organized as follows: Section 2 explains the structure of the Sweave files defining the exercises and demonstrates how the final output file is derived from the orig- inal R and LATEX code. In Section 3, the structure of the master LATEX file for constructing the final PDF file from the exercise files is presented. Finally Section 4 illustrates how to use the package in practice and how exams can be customized. Experience with the development of exercises and the application of the package are discussed in Section 5. Section 6 concludes the paper with a summary. 2. Exercises Each exercise is contained in a separate Sweave file and typically represents an exemplary application of a statistical procedure. It needs to contain (1) a question and a solution description which are encapsulated in LATEX environments of the corresponding names and (2) some meta-information about the exercise such as type and the solution. To allow for variability, the data for the exercise can be generated within the Sweave file in a code chunk (typically suppressed in the final document). Meta-information for the examples needs to be provided, e.g., for computing with the solution within R or for generating lists with solutions. In Table 1, the Sweave file for a simple exercise asking students to compute a one-sample t test statistic is shown for illustration. The four different blocks (R code with DGP, question environment, solution environment, meta-information) can be easily distinguished. The LATEX file generated from a call to Sweave() is shown in Table 2, and the final compiled PDF output is provided in Table 3. The R code for the DGP is used as in any other Sweave document: The code chunk is framed by >= and @ and options in the header control formatting (typically suppressing the display in the final document, as in this example). For further information about the application of Sweave and a detailed description of the different options see Leisch (2012a,b). The core of an exercise are two blocks for the question and the solution in their accordingly named environments. The values generated by the DGP are typically included using \\Sexpr{} statements. Furthermore, question/solution might contain graphics and/or R output created by Sweave. To include the LATEX output (see Table 2) in some master LATEX file, this needs to define the question and solution environment. This mechanism can be used to control the display, e.g., to suppress the solution in an exam but to display it in associated self-study material (see Section 3 for further details). Finally, some meta-information needs to be provided. All meta-information commands are in LATEX style but are actually commented out and hidden in the final output file. There are four commands2: ❼ \\extype{}: type of question. It may be either mchoice for multiple-choice questions, num for questions with a numeric result or string for questions with a (short) text answer. ❼ \\exsolution{}: solution. It contains the numeric solution, a string of zeros and ones for multiple-choice questions or a character string. For confidence intervals, it may also specify two numeric solutions of type \\exsolution{lower}{upper}. 2Note that version 2 provides many additional commands, especially for e-learning output and other custom interfaces. 4 Automatic Generation of Exams in R >= ## DATA GENERATION n <- sample(120:250, 1) mu <- sample(c(125, 200, 250, 500, 1000), 1) y <- rnorm(n, mean = mu * runif(1, min = 0.9, max = 1.1), sd = mu * runif(1, min = 0.02, max = 0.06)) ## QUESTION/ANSWER GENERATION Mean <- round(mean(y), digits = 1) Var <- round(var(y), digits = 2) tstat <- round((Mean - mu)/sqrt(Var/n), digits = 3) @ \\begin{question} A machine fills milk into $\\Sexpr{mu}$ml packages. It is suspected that the machine is not working correctly and that the amount of milk filled differs from the setpoint $\\mu_0 = \\Sexpr{mu}$. A sample of $\\Sexpr{n}$ packages filled by the machine are collected. The sample mean $\\bar{y}$ is equal to $\\Sexpr{Mean}$ and the sample variance $s^2_{n-1}$ is equal to $\\Sexpr{Var}$. Test the hypothesis that the amount filled corresponds on average to the",
		"Source": "exams.pdf\r"
	},
	{
		"Question": "setpoint. What is the absolute value of the $t$~test statistic?",
		"Answer": "\\end{question} \\begin{solution} The $t$~test statistic is calculated by: \\begin{eqnarray*} t & = & \\frac{\\bar y - \\mu_0}{\\sqrt{\\frac{s^2_{n-1}}{n}}} = \\frac{\\Sexpr{Mean} - \\Sexpr{mu}}{\\sqrt{\\frac{\\Sexpr{Var}}{\\Sexpr{n}}}} = \\Sexpr{tstat}. \\end{eqnarray*} The absolute value of the $t$~test statistic is thus equal to $\\Sexpr{fmt(abs(tstat), 3)}$. \\end{solution} %% META-INFORMATION %% \\extype{num} %% \\exsolution{\\Sexpr{fmt(abs(tstat), 3)}} %% \\exname{t statistic} %% \\extol{0.01} Table 1: A simple Sweave exercise: tstat.Rnw. Bettina Gru¨n, Achim Zeileis 5 \\begin{question} A machine fills milk into $500$ml packages. It is suspected that the machine is not working correctly and that the amount of milk filled differs from the setpoint $\\mu_0 = 500$. A sample of $226$ packages filled by the machine are collected. The sample mean $\\bar{y}$ is equal to $517.2$ and the sample variance $s^2_{n-1}$ is equal to $262.56$. Test the hypothesis that the amount filled corresponds on average to the",
		"Source": "exams.pdf\r"
	},
	{
		"Question": "setpoint. What is the absolute value of the $t$~test statistic?",
		"Answer": "\\end{question} \\begin{solution} The $t$~test statistic is calculated by: \\begin{eqnarray*} t & = & \\frac{\\bar y - \\mu_0}{\\sqrt{\\frac{s^2_{n-1}}{n}}} = \\frac{517.2 - 500}{\\sqrt{\\frac{262.56}{226}}} = 15.958. \\end{eqnarray*} The absolute value of the $t$~test statistic is thus equal to $15.958$. \\end{solution} %% META-INFORMATION %% \\extype{num} %% \\exsolution{15.958} %% \\exname{t statistic} %% \\extol{0.01} Table 2: LATEX output of Sweave(tstat.Rnw). ❼ \\exname{}: a name or description. This is some short informative text, only used for printing of solutions within R. ❼ \\extol{}: optional tolerance limit(s). For numeric solutions a tolerance limit can be specified; by default it is assumed to be 0. This can be useful for the automatic evaluation of numeric solutions if some deviation from the correct answer is allowed (e.g., due to rounding errors). If a single tolerance value is supplied, a symmetric interval around the true value is used. (Version 1 of the exams package also supported UPDATE asymmetric tolerance intervals when two tolerance values were provided. However, this has not been implemented for any of the version 2 interfaces.) 6 Automatic Generation of Exams in R 1. Problem A machine fills milk into 500ml packages. It is suspected that the machine is not working correctly and that the amount of milk filled differs from the setpoint µ0 = 500. A sample of 226 packages filled by the machine are collected. The sample mean y¯ is equal to 517.2 and the sample variance s2 n−1 is equal to 262.56. Test the hypothesis that the amount filled corresponds on average to the setpoint. What",
		"Source": "exams.pdf\r"
	},
	{
		"Question": "is the absolute value of the t test statistic?",
		"Answer": "Solution The t test statistic is calculated by: t = y¯ − µ0√ s 2 n−1 n = 517.2− 500√ 262.56 226 = 15.958. The absolute value of the t test statistic is thus equal to 15.958. Table 3: Display of processed exercise from exams2pdf(tstat.pdf). The meta-information is read from the LATEX file (e.g., as in Table 2) and hence all values can be dynamically computed using \\Sexpr{}. Typically, this will be necessary for the correct solution, but similarly the descriptive name, the tolerance allowed, or even the type of the question could be data-driven and determined by the DGP. The user does not have to go from the Sweave file (Table 1) to the LATEX file (Table 2) to the PDF file (Table 3) by hand. The function exams2pdf() from package exams carries out all of these steps automatically. (In version 1 of the package the function exams() wasUPDATE provided. While this is still contained in the package, it is recommended to use the newer and more flexible exams2pdf() for new projects.) R> library(exams) R> set.seed(1090) R> tstat_ex <- exams2pdf(tstat.Rnw) After loading the package, exams2pdf() is called with the Sweave file name. The final PDF file is displayed on screen by default (for further options see Section 4). The PDF viewer used depends on the operating system: On Windows, the application specified in the systems file associations is used. On other systems (e.g., Linux or Mac OS), the PDF viewer specified in the options (see getOption(pdfviewer)) is started. exams2pdf() returns a list of exams",
		"Source": "exams.pdf\r"
	},
	{
		"Question": "which is a list of exercises (see Zeileis et al. 2014, for details). To extract anexams_metainfo",
		"Answer": "object for pretty printing in R, the function exams_metainfo() can be used: R> exams_metainfo(tstat_ex) exam1 Bettina Gru¨n, Achim Zeileis 7 1. t statistic: 15.958 (15.948--15.968) 3. Combining exercises: The master LATEX file To produce the PDF for an exam, the exercises need to be weaved, tied together in the master LATEX file and subsequently processed to PDF. More precisely, exams2pdf() takes the following approach: 1. Collect all Sweave files for the exercises, the master LATEX file(s) and potentially addi- tionally specified input files. 2. Copy all files to a (temporary, by default) directory. 3. Run Sweave() for each exercise. 4. Produce a copy of the master LATEX file(s) in which certain control structures are sub- stituted by dynamically generated LATEX commands (e.g., for including the exercises). 5. Run texi2dvi() for each master LATEX file. 6. Store the resulting PDF file(s) in an output directory or display it on the screen (for a single file only, by default). Thus, the only thing needed to combine several independent exercises to an exam is a master LATEX file. Its basic structure is rather straightforward but for more elaborate layouts it can become quite complex. Package exams provides various examples of master LATEX files in the inst/tex/ directory of the source package. The simplest one is plain.tex (see Table 4)",
		"Source": "exams.pdf\r"
	},
	{
		"Question": "which is described here to provide a first overview.",
		"Answer": "The structure of plain.tex is rather straightforward: First, the document class is defined and then necessary add-on packages are loaded.3 Then the environments for question and solution are defined (as part of an itemize or enumerate list). Finally, the document starts and consists only of an enumerate list. In Step 4 of the algorithm described above, the control command %% \\exinput{exercises} is replaced by (a sequence of) \\input{filename}, e.g., \\input{exercise1.tex}4 for the first exercise etc. Optionally, the %% \\exinput{exercises} comment can also be omitted in the template. Then, the user can place his/her own \\input{exercise1.tex}, \\input{exercise2.tex}, . . . in the master LATEX file. This re- quires knowing the correct number of exercises but adds the flexibility of including arbitrary text/formatting between the exercises. Thus, all appearance options can be controlled in the LATEX code of the master file, e.g., by changing the definitions of the question/solution environments or by modifying the code around the \\exinput{} command. As an example, one might want to show only the questions and hide the solutions in the PDF. This is easily obtained by changing the definition of the solution environment to \\newenvironment{solution}{\\comment}{\\endcomment}. 3Note that Sweave.sty is included for displaying R output. texi2dvi() ensures that this style file will be found by including Rs texmf directory in the TEXINPUTS path. 4Leading zeros are added if n has more than one digit, e.g., exercise01.tex if there are between ten and 99 exercises. 8 Automatic Generation of Exams in R \\documentclass[a4paper]{article} \\usepackage{a4wide,color,Sweave,url,amsmath,booktabs,longtable} \\newenvironment{question}{\\item \\textbf{Problem}\\newline}{} \\newenvironment{solution}{\\textbf{Solution}\\newline}{} \\newenvironment{answerlist}{\\renewcommand{\\labelenumi}{(\\alph{enumi})} \\begin{enumerate}}{\\end{enumerate}} \\begin{document} \\begin{enumerate} %% \\exinput{exercises} \\end{enumerate} \\end{document} Table 4: A simple master LATEX file: plain.tex. The structure described so far is completely static, except for the \\exinput{} command. In fact, exercises is not the only argument allowed; at the moment two further arguments can be used to modify aspects of the master LATEX file dynamically: ❼ \\exinput{exercises}: Inclusion of exercises. Replaced by: \\input{filename} (one for each exercise). Example: \\input{exercise1.tex}. ❼ \\exinput{questionnaire}: Inclusion of questionnaires, e.g., for cover sheets. Replaced by: \\exnum{. . .}, \\exmchoice{. . .}, or \\exstring{. . .}, respectively (one for each exercise). Example: \\exnum{}{}{}{}{1}{5}{9}{5}{8}. ❼ \\exinput{header}: Further commands and definitions. Replaced by: \\command{value} (one for each header command). Example: \\Date{2017-03-17}. For the latter two, the master LATEX file has to define the commands that are used in the re- placement step, e.g., \\exnum has to be a command that takes nine arguments (corresponding to six and three digits before and after the decimal point for numeric solutions), \\exmchoice has to take one required and one or more optional arguments such as \\exmchoice{X}[][X][][] (corresponding to the logical multiple-choice answers) and \\exstring has to take only one ar- gument (corresponding to the solution string). (The implementation of mchoice was slightlyUPDATE different in version 1 of the package where only a fixed number of five multiple choices was supported.) For the header, arbitrary commands can be set up, see Section 4 for details. Two master LATEX files that illustrate all of the commands above are provided in exams: exam.tex and solution.tex. exam.tex can be used to generate exams including a cover sheet for students to fill in their names as well as their answers to the problems (hiding Bettina Gru¨n, Achim Zeileis 9 solutions for the exercises, obviously). solution.tex produces PDF files containing a cover sheet similar to exam.tex but with the correct answers already filled in. Furthermore, the solution environments are displayed for each exercise. 4. Application and customization In the simple case where only a single Sweave exercise is processed running exams2pdf() essentially corresponds to first calling Sweave() and then texi2dvi() on the file after in- cluding it in a master LATEX file. This is quite convenient, especially for non-experts (in R and/or LATEX), but beyond that not much simplification is gained by exams2pdf(). The main advantages of the function, however, are its flexibility and customizability: It controls the (dynamic) combination of the Sweave and LATEX files and allows for ❼ construction of exams with stratified sampling of exercises, ❼ automatic generation of multiple copies (potentially of multiple layouts) with suitable names and storage, ❼ inclusion of a suitable cover page with answer fields, ❼ collection of meta-information for problems and solutions in an R object. In the following, we illustrate how exams2pdf() can be employed to exploit all of these features. First, the interface of exams2pdf() is briefly described before using it to generate a small set of exams with corresponding solutions. Function exams2pdf() has the following arguments: exams2pdf(file, n = 1L, nsamp = NULL, dir = ., template = NULL, inputs = NULL, header = list(Date = Sys.Date()), name = NULL, control = NULL, encoding = , quiet = TRUE, transform = NULL, edir = NULL, tdir = NULL, sdir = NULL, verbose = FALSE, points = NULL, ...)",
		"Source": "exams.pdf\r"
	},
	{
		"Question": "where file specifies a list/vector of exercise Sweave files (see Section 2), template is the name",
		"Answer": "of the master LATEX file (see Section 3), and n is the number of random replications. The re- maining arguments control details of the processing, e.g., the directories for input/output files. A technical manual is available on the help page ?exams2pdf, a brief hands-on introduction to selected arguments is given below: file: This is either a character vector containing the file names of Sweave exercises or a list of such vectors, e.g., R> myexam  odir <- tempfile() Assume that we want a different ID for each exam. To accomplish this, we define a function",
		"Source": "exams.pdf\r"
	},
	{
		"Question": "which is used to substitute a different \\ID{myexamii} command in the header of each exam.",
		"Answer": "(The LATEX command \\ID{} has to be defined in the master LATEX files.) R> getID  getID(1) Bettina Gru¨n, Achim Zeileis 11 [1] myexam01 Using these arguments, a set of exams can be easily produced: R> set.seed(1090) R> ex  list.files(odir) [1] exam1.pdf exam2.pdf exam3.pdf exam4.pdf [5] exam5.pdf solution1.pdf solution2.pdf solution3.pdf [9] solution4.pdf solution5.pdf and can now be easily inspected by the reader. If in addition to the PDF exams and solutions, further information about the exams is needed the ex list returned could be stored for future reference. This contains all LATEX code for questions/solutions along with the metainformation about the correct answers etc. The latter can also be extracted and printed within R: R> sol  print(sol, 1) exam1 1. Parallel boxplots: 1, 2, 4 2. t statistic: 4.52 (4.51--4.53) 3. 2-sample t-test: 2, 3 4. Prediction: 267.66 (267.65--267.67) 5. Scatterplot: 1, 4 6. Relative frequencies: 1, 4, 5 R> print(sol, exam5) exam5 1. Parallel boxplots: 1, 2, 4 2. t statistic: 48.203 (48.193--48.213) 3. 2-sample t-test: 1, 5 4. Prediction: 205 (204.99--205.01) 5. Scatterplot: 1, 2 6. Relative frequencies: 1, 5 12 Automatic Generation of Exams in R For numeric results, the solution is displayed, possibly including tolerance limits (if non-zero). For multiple-choice answers, the true statements (coded with 1-5) are listed and the false ones are omitted. Consequently, if a multiple-choice question has no true statements, no numbers are displayed. 5. Discussion Infrastructure vs. content Package exams provides the technological framework for the generation of structured exams, especially for large-lecture courses. Given a relatively simple structure of exams (sequence of stand-alone exercises with multiple-choice/numeric/short text solutions), it is designed to be as flexible as possible. Thus, users should not have to worry about implementation details and can focus on the specification of the content and the development of the pool of exercises. While the packages structure can aid the design and development of the exercises, the package can, of course, not assure that good exercises (from an educational point of view) are generated. As this is beyond the scope of exams, some brief pointers to the relevant literature on statistical education and assessment are given here: Gal and Garfield (1997) and Garfield and Chance (2000) discuss issues such as topics covered and skills developed in statistics courses as well as suitable ways of assessment. The development of effective multiple-choice questions which force the student to understand underlying statistical concepts is crucial and often not straightforward. Strategies for good multiple-choice questions, especially if they are also used for self-study materials, are suggested by Klinke (2004). Strategies for setting up exercises As pointed out above, exams does not really address the problem of designinggoodexercises. However, the infrastructure supports several commonly-used strategies for setting up different types of exercises which in turn can support the decisions about the content. For example, in the case of multiple-choice two typical strategies are: Either only one option is correct or any one option can be correct or false. In the former case, the evaluation typically penalizes incorrect answers (to avoid random guessing) while in the latter case the number of potential patterns is sufficiently large that no penalization is necessary. In both cases, it is good practice to check the DGP employed for generating the answers and look at the resulting distribution of answer patterns. For exercises with numerical solutions, on the other hand, a typical problem in practice is how to set the tolerance. While the instructor will want to catch typical mistakes (e.g., wrong standardization, etc.), certain imprecisions (e.g., rounding errors in intermediate steps) might be tolerable. The simpler and somewhat more rigid approach to this problem is to practice with the students how to avoid the imprecisions and just require a certain accuracy of the solution (as in the t test example in Tables 1 and 2). A more flexible approach would be to derive the tolerance dynamically (as part of the DGP) assuring that common small imprecisions lead to results within tolerance limits while typical mistakes are not. Experiences at WU Wien During 2007, exams was employed by about 10-15 lecturers at the Department of Statistics Bettina Gru¨n, Achim Zeileis 13 and Mathematics of WU Wien for jointly developing materials for the basic statistics lecture. With package exams we were able to address the technological requirements and facilitate the development process. All lecturers involved were familiar with R and LATEX (which are both available on all standard platforms) and could thus contribute to the pool of exercises. To do so, they just needed to know the structure of the exercise Sweave files while different master LATEX files (for the departments exams, exercise collections, etc.) have been written by the authors of the exams package. As an additional tool we decided to use Subversion (SVN, Pilato, Collins-Sussman, and Fitzpatrick 2004) for version control in order to provide all lec- turers involved with access to all resources. In combination with the package this approach proved to be rather successful in addressing the needs of multi-author and cross-platform development. Since Spring 2008, exams is used at WU Wien for generating collections of exercises and trial exams (both available prior to the actual exam) as well as the exams and associated solutions (which are e-mailed to the students individually after correction of the test). Exams containing numeric answers are still corrected by hand but for exams con- sisting entirely of multiple/single-choice answers automatic scanning using optical character recognition (OCR) is used.5 6. Summary Package exams provides a framework for automatic generation of simple (statistical) exams and associated self-study materials. It is based on independent exercises in Sweave format",
		"Source": "exams.pdf\r"
	},
	{
		"Question": "which can be compiled in exams (or other collections of exercises) by providing one (or more)",
		"Answer": "master LATEX template(s). Because contributing to the pool of exercises just requires knowl- edge of Sweave and minimal markup for meta-information, exams facilitates joint development of lecture materials. An extension of the package to e-learning exams, e.g., for Moodle or OLAT/OpenOLAT is described in Zeileis et al. (2014). Acknowledgments We are indebted to our colleagues at the Department of Statistics and Mathematics at WU Wien - in particular Regina Tu¨chler and Josef Leydold - for testing and challenging the code and making suggestions for improvement. We would like to thank two anonymous referees and one associate editor for their valuable comments which led to several improvements. This research was partially supported by the Austrian Science Foundation (FWF) under Hertha- Firnberg grant T351. References de Leeuw J (2001). Reproducible Research: The Bottom Line.Technical Report 2001031101, Department of Statistics Papers, University of California, Los Angeles. URL http:// repositories.cdlib.org/uclastat/papers/2001031101/. 5We also have an R implementation for scanning multiple/single-choice exams. However, this is somewhat geared towards the exam sheets used at WU Wien and Universita¨t Innsbruck and hence not part of the exams package. Readers interested in this code should contact the package authors. 14 Automatic Generation of Exams in R Gal I, Garfield JB (eds.) (1997). The Assessment Challenge in Statistics Education. IOS Press, Netherlands. Garfield JB, Chance B (2000). Assessment in Statistics Education: Issues and Challenges. Mathematical Thinking and Learning, 2(1/2), 99-125. Gru¨n B, Zeileis A (2009). Automatic Generation of Exams in R. Journal of Statistical Software, 29(10), 1-14. URL http://www.jstatsoft.org/v29/i10/. Klinke S (2004). Q&A - Variable Multiple Choice Exercises with Commented Answers. In J Antoch (ed.), COMPSTAT 2004 - Proceedings in Computational Statistics, pp. 1323- 1328. Physica Verlag, Heidelberg. Knuth DE (1984). The TEXbook, volume A of Computers and Typesetting. Addison-Wesley, Reading, Massachusetts. Knuth DE (1992). Literate Programming, volume 27 of CSLI Lecture Notes. Center for the Study of Language and Information, Stanford, California. Lamport L (1994). LATEX: A Document Preparation System. 2nd edition. Addison-Wesley, Reading, Massachusetts. Leisch F (2002). Dynamic Generation of Statistical Reports Using Literate Data Analysis. In W Ha¨rdle, B Ro¨nz (eds.), COMPSTAT 2002 - Proceedings in Computational Statistics, pp. 575-580. Physica Verlag, Heidelberg. Leisch F (2012a). Sweave FAQ. URL http://www.stat.uni-muenchen.de/~leisch/ Sweave/. Leisch F (2012b). Sweave User Manual. URL http://www.stat.uni-muenchen.de/ ~leisch/Sweave/. Leisch F, Rossini AJ (2003). Reproducible Statistical Research. Chance, 16(2), 46-50. Pilato CM, Collins-Sussman B, Fitzpatrick BW (2004). Version Control with Subversion. OReilly. Full book available online at http://svnbook.red-bean.com/. R Development Core Team (2008). R: A Language and Environment for Statistical Computing. R Foundation for Statistical Computing, Vienna, Austria. ISBN 3-900051-07-0, URL http: //www.R-project.org/. Rossini AJ (2001). Literate Statistical Practice. In K Hornik, F Leisch (eds.), Proceed- ings of the 2nd International Workshop on Distributed Statistical Computing, Vienna, Austria. ISSN 1609-395X, URL http://www.ci.tuwien.ac.at/Conferences/DSC-2001/ Proceedings/. Zeileis A, Umlauf N, Leisch F (2014). Flexible Generation of E-Learning Exams in R: Moodle Quizzes, OLAT Assessments, and Beyond. Journal of Statistical Software, 58(1), 1-36. URL http://www.jstatsoft.org/v58/i01/. Bettina Gru¨n, Achim Zeileis 15 Affiliation: Bettina Gru¨n Institut fu¨r Angewandte Statistik Johannes Kepler Universita¨t Linz Altenbergerstraße 69 4040 Linz, Austria E-mail: Bettina.Gruen@jku.at URL: http://ifas.jku.at/gruen/ Achim Zeileis Department of Statistics Faculty of Economics and Statistics Universita¨t Innsbruck Universita¨tsstr. 15 6020 Innsbruck, Austria E-mail: Achim.Zeileis@R-project.org URL: http://eeecon.uibk.ac.at/~zeileis/",
		"Source": "exams.pdf\r"
	},
	{
		"Question": "What is a requirement?",
		"Answer": " It may range from a high-level abstract statement of a  service or of a system constraint to a detailed  mathematical functional specification.   This is inevitable as requirements may serve a dual  function   May be the basis for a bid for a contract - therefore must be open  to interpretation;   May be the basis for the contract itself - therefore must be  defined in detail;   Both these statements may be called requirements.  4 Chapter 3  Requirements engineering  Requirements abstraction (Davis)  If a company wishes to let a contract for a large software development  project, it must define its needs in a sufficiently abstract way that a  solution is not pre-defined. The requirements must be written so that  several contractors can bid for the contract, offering, perhaps, different  ways of meeting the client organization‟s needs. Once a contract has  been awarded, the contractor must write a system definition for the  client in more detail so that the client understands and can validate what  the software will do. Both of these documents may be called the  requirements document for the system.  5 Chapter 3  Requirements engineering  Types of requirement   User requirements   Statements in natural language plus diagrams of the services the  system provides and its operational constraints. Written for  customers.   System requirements   A structured document setting out detailed descriptions of the  system‟s functions, services and operational constraints. Defines",
		"Source": "Chapter3.pdf\r"
	},
	{
		"Question": "what should be implemented so may be part of a contract",
		"Answer": "between client and contractor.  6 Chapter 3  Requirements engineering  User and system requirements  7 Chapter 3  Requirements engineering  Readers of different types of requirements  specification  8 Chapter 3  Requirements engineering  Functional and non-functional requirements   Functional requirements   Statements of services the system should provide, how the  system should react to particular inputs and how the system  should behave in particular situations.   May state what the system should not do.   Non-functional requirements   Constraints on the services or functions offered by the system  such as timing constraints, constraints on the development  process, standards, etc.   Often apply to the system as a whole rather than individual  features or services.   Domain requirements   Constraints on the system from the domain of operation  9 Chapter 3  Requirements engineering  Functional requirements   Describe functionality or system services.   Depend on the type of software, expected users and the  type of system where the software is used.   Functional user requirements may be high-level  statements of what the system should do.   Functional system requirements should describe the  system services in detail.  10 Chapter 3  Requirements engineering  Functional requirements for the MHC-PMS   A user shall be able to search the appointments lists for  all clinics.   The system shall generate each day, for each clinic, a  list of patients who are expected to attend appointments  that day.    Each staff member using the system shall be uniquely  identified by his or her 8-digit employee number.  11 Chapter 3  Requirements engineering  Requirements imprecision   Problems arise when requirements are not precisely  stated.   Ambiguous requirements may be interpreted in different  ways by developers and users.   Consider the term „search‟ in requirement 1   User intention - search for a patient name across all  appointments in all clinics;   Developer interpretation - search for a patient name in an  individual clinic. User chooses clinic then search.  12 Chapter 3  Requirements engineering  Requirements completeness and consistency   In principle, requirements should be both complete and  consistent.   Complete   They should include descriptions of all facilities required.   Consistent   There should be no conflicts or contradictions in the descriptions  of the system facilities.   In practice, it is impossible to produce a complete and  consistent requirements document.  13 Chapter 3  Requirements engineering  Non-functional requirements   These define system properties and constraints e.g.  reliability, response time and storage requirements.  Constraints are I/O device capability, system  representations, etc.   Process requirements may also be specified mandating  a particular IDE, programming language or development  method.   Non-functional requirements may be more critical than  functional requirements. If these are not met, the system  may be useless.  14 Chapter 3  Requirements engineering  Types of nonfunctional requirement  15 Chapter 3  Requirements engineering  Non-functional requirements implementation   Non-functional requirements may affect the overall  architecture of a system rather than the individual  components.   For example, to ensure that performance requirements are met,  you may have to organize the system to minimize  communications between components.   A single non-functional requirement, such as a security  requirement, may generate a number of related  functional requirements that define system services that  are required.   It may also generate requirements that restrict existing  requirements.   16 Chapter 3  Requirements engineering  Non-functional classifications   Product requirements   Requirements which specify that the delivered product must  behave in a particular way e.g. execution speed, reliability, etc.   Organisational requirements   Requirements which are a consequence of organisational  policies and procedures e.g. process standards used,  implementation requirements, etc.   External requirements   Requirements which arise from factors which are external to the  system and its development process e.g. interoperability  requirements, legislative requirements, etc.  17 Chapter 3  Requirements engineering  Examples of nonfunctional requirements in the  MHC-PMS  Product requirement  The MHC-PMS shall be available to all clinics during normal working  hours (Mon-Fri, 0830-17.30). Downtime within normal working hours  shall not exceed five seconds in any one day.    Organizational requirement  Users of the MHC-PMS system shall authenticate themselves using  their health authority identity card.    External requirement  The system shall implement patient privacy provisions as set out in  HStan-03-2006-priv.     18 Chapter 3  Requirements engineering  Goals and requirements   Non-functional requirements may be very difficult to state  precisely and imprecise requirements may be difficult to  verify.    Goal   A general intention of the user such as ease of use.   Verifiable non-functional requirement   A statement using some measure that can be objectively tested.   Goals are helpful to developers as they convey the  intentions of the system users.  19 Chapter 3  Requirements engineering  Usability requirements   The system should be easy to use by medical staff and  should be organized in such a way that user errors are  minimized. (Goal)  Medical staff shall be able to use all the system functions  after four hours of training. After this training, the  average number of errors made by experienced users  shall not exceed two per hour of system use. (Testable  non-functional requirement)      20 Chapter 3  Requirements engineering  Metrics for specifying nonfunctional  requirements  Property Measure  Speed Processed transactions/second  User/event response time  Screen refresh time  Size Mbytes  Number of ROM chips  Ease of use Training time  Number of help frames  Reliability Mean time to failure  Probability of unavailability  Rate of failure occurrence  Availability  Robustness Time to restart after failure  Percentage of events causing failure  Probability of data corruption on failure  Portability Percentage of target dependent statements  Number of target systems  21 Chapter 3  Requirements engineering  Domain requirements   The system‟s operational domain imposes requirements  on the system.   For example, a train control system has to take into account the  braking characteristics in different weather conditions.   Domain requirements be new functional requirements,  constraints on existing requirements or define specific  computations.   If domain requirements are not satisfied, the system may  be unworkable.  22 Chapter 3  Requirements engineering  Domain requirements problems   Understandability   Requirements are expressed in the language of the application  domain;   This is often not understood by software engineers developing  the system.   Implicitness   Domain specialists understand the area so well that they do not  think of making the domain requirements explicit.  23 Chapter 3  Requirements engineering  Key points   Requirements for a software system set out what the  system should do and define constraints on its operation  and implementation.   Functional requirements are statements of the services  that the system must provide or are descriptions of how  some computations must be carried out.    Non-functional requirements often constrain the system  being developed and the development process being  used.   They often relate to the emergent properties of the  system and therefore apply to the system as a whole.   24 Chapter 3  Requirements engineering  Chapter 3 - Requirements Engineering  Lecture 2  25 Chapter 3  Requirements engineering  The software requirements document   The software requirements document is the official  statement of what is required of the system developers.   Should include both a definition of user requirements  and a specification of the system requirements.   It is NOT a design document. As far as possible, it  should set of WHAT the system should do rather than",
		"Source": "Chapter3.pdf\r"
	},
	{
		"Question": "HOW it should do it.",
		"Answer": "26 Chapter 3  Requirements engineering  Agile methods and requirements  Many agile methods argue that producing a  requirements document is a waste of time as  requirements change so quickly.   The document is therefore always out of date.   This is practical for business systems but problematic for  systems that require a lot of pre-delivery analysis (e.g.  critical systems) or systems developed by several teams.  27 Chapter 3  Requirements engineering  Users of a requirements document  28 Chapter 3  Requirements engineering  Requirements document variability   Information in requirements document depends on type  of system and the approach to development used.   Systems developed incrementally will, typically, have  less detail in the requirements document.   Requirements documents standards have been  designed e.g. IEEE standard. These are mostly  applicable to the requirements for large systems  engineering projects.  Chapter 3  Requirements engineering 29  The structure of a requirementsdocument  Chapter Description  Preface This should define the expected readership of the document and describe  its version history, including a rationale for the creation of a new version  and a summary of the changes made in each version.   Introduction This should describe the need for the system. It should briefly describe the  system‟s functions and explain how it will work with other systems. It  should also describe how the system fits into the overall business or  strategic objectives of the organization commissioning the software.  Glossary This should define the technical terms used in the document. You should  not make assumptions about the experience or expertise of the reader.  User requirements  definition  Here, you describe the services provided for the user. The nonfunctional  system requirements should also be described in this section. This  description may use natural language, diagrams, or other notations that are  understandable to customers. Product and process standards that must be  followed should be specified.  System architecture This chapter should present a high-level overview of the anticipated system  architecture, showing the distribution of functions across system modules.  Architectural components that are reused should be highlighted.  30 Chapter 3  Requirements engineering  The structure of a requirements document  Chapter Description  System  requirements  specification  This should describe the functional and nonfunctional requirements in more detail.  If necessary, further detail may also be added to the nonfunctional requirements.  Interfaces to other systems may be defined.  System models This might include graphical system models showing the relationships between  the system components and the system and its environment. Examples of  possible models are object models, data-flow models, or semantic data models.   System evolution This should describe the fundamental assumptions on which the system is based,  and any anticipated changes due to hardware evolution, changing user needs,  and so on. This section is useful for system designers as it may help them avoid  design decisions that would constrain likely future changes to the system.  Appendices These should provide detailed, specific information that is related to the  application being developed; for example, hardware and database descriptions.  Hardware requirements define the minimal and optimal configurations for the  system. Database requirements define the logical organization of the data used  by the system and the relationships between data.   Index Several indexes to the document may be included. As well as a normal alphabetic  index, there may be an index of diagrams, an index of functions, and so on.  31 Chapter 3  Requirements engineering  Requirements specification   The process of writing down the user and system  requirements in a requirements document.   User requirements have to be understandable by end- users and customers who do not have a technical  background.   System requirements are more detailed requirements  and may include more technical information.   The requirements may be part of a contract for the  system development   It is therefore important that these are as complete as possible.  Chapter 3  Requirements engineering 32  Ways of writing a system requirements  specification   Notation Description  Natural language The requirements are written using numbered sentences in natural language.  Each sentence should express one requirement.  Structured natural  language   The requirements are written in natural language on a standard form or  template. Each field provides information about an aspect of the  requirement.  Design description  languages  This approach uses a language like a programming language, but with more  abstract features to specify the requirements by defining an operational  model of the system. This approach is now rarely used although it can be  useful for interface specifications.  Graphical notations Graphical models, supplemented by text annotations, are used to define the  functional requirements for the system; UML use case and sequence  diagrams are commonly used.  Mathematical  specifications  These notations are based on mathematical concepts such as finite-state  machines or sets. Although these unambiguous specifications can reduce  the ambiguity in a requirements document, most customers don‟t understand  a formal specification. They cannot check that it represents what they want  and are reluctant to accept it as a system contract  33 Chapter 3  Requirements engineering  Requirements and design   In principle, requirements should state what the system  should do and the design should describe how it does  this.   In practice, requirements and design are inseparable   A system architecture may be designed to structure the  requirements;   The system may inter-operate with other systems that generate  design requirements;   The use of a specific architecture to satisfy non-functional  requirements may be a domain requirement.   This may be the consequence of a regulatory requirement.  Chapter 3  Requirements engineering 34  Natural language specification   Requirements are written as natural language sentences  supplemented by diagrams and tables.   Used for writing requirements because it is expressive,  intuitive and universal. This means that the requirements   can be understood by users and customers.  Chapter 3  Requirements engineering 35  Guidelines for writing requirements   Invent a standard format and use it for all requirements.   Use language in a consistent way. Use shall for  mandatory requirements, should for desirable  requirements.   Use text highlighting to identify key parts of the  requirement.   Avoid the use of computer jargon.   Include an explanation (rationale) of why a requirement  is necessary.  Chapter 3  Requirements engineering 36  Problems with natural language   Lack of clarity    Precision is difficult without making the document difficult to  read.   Requirements confusion   Functional and non-functional requirements tend to be mixed-up.   Requirements amalgamation   Several different requirements may be expressed together.  Chapter 3  Requirements engineering 37  Example requirements for the insulin pump  software system  3.2 The system shall measure the blood sugar and deliver insulin, if required, every 10  minutes. (Changes in blood sugar are relatively slow so more frequent measurement is  unnecessary; less frequent measurement could lead to unnecessarily high sugar levels.)    3.6 The system shall run a self-test routine every minute with the conditions to be  tested and the associated actions defined in Table 1. (A self-test routine can discover  hardware and software problems and alert the user to the fact the normal operation  may be impossible.)    38 Chapter 3  Requirements engineering  Structured specifications   An approach to writing requirements where the freedom  of the requirements writer is limited and requirements  are written in a standard way.   This works well for some types of requirements e.g.  requirements for embedded control system but is  sometimes too rigid for writing business system  requirements.  Chapter 3  Requirements engineering 39  Form-based specifications   Definition of the function or entity.   Description of inputs and where they come from.   Description of outputs and where they go to.   Information about the information needed for the  computation and other entities used.   Description of the action to be taken.   Pre and post conditions (if appropriate).   The side effects (if any) of the function.  Chapter 3  Requirements engineering 40  A structured specification of a requirement for  an insulin pump  41 Chapter 3  Requirements engineering  Tabular specification   Used to supplement natural language.   Particularly useful when you have to define a number of  possible alternative courses of action.   For example, the insulin pump systems bases its  computations on the rate of change of blood sugar level  and the tabular specification explains how to calculate  the insulin requirement for different scenarios.  Chapter 3  Requirements engineering 42  Tabular specification of computation for an  insulin pump  43 Chapter 3  Requirements engineering  Requirements engineering processes   The processes used for RE vary widely depending on  the application domain, the people involved and the  organisation developing the requirements.   However, there are a number of generic activities  common to all processes   Requirements elicitation;   Requirements analysis;   Requirements validation;   Requirements management.   In practice, RE is an iterative activity in which these  processes are interleaved.  44 Chapter 3  Requirements engineering  A spiral view of the requirements engineering  process  45 Chapter 3  Requirements engineering  Requirements elicitation and analysis   Sometimes called requirements elicitation or  requirements discovery.   Involves technical staff working with customers to find  out about the application domain, the services that the  system should provide and the system‟s operational  constraints.  May involve end-users, managers, engineers involved in  maintenance, domain experts, trade unions, etc. These  are called stakeholders.  46 Chapter 3  Requirements engineering  Requirements elicitation and analysis   Software engineers work with a range of system  stakeholders to find out about the application domain,  the services that the system should provide, the required  system performance, hardware constraints, other  systems, etc.   Stages include:   Requirements discovery,   Requirements classification and organization,   Requirements prioritization and negotiation,   Requirements specification.    Chapter 3  Requirements engineering 47  Therequirements elicitation and analysis  process  48 Chapter 3  Requirements engineering  Process activities   Requirements discovery   Interacting with stakeholders to discover their requirements.  Domain requirements are also discovered at this stage.   Requirements classification and organisation   Groups related requirements and organises them into coherent  clusters.   Prioritisation and negotiation   Prioritising requirements and resolving requirements conflicts.   Requirements specification   Requirements are documented and input into the next round of  the spiral.  Chapter 3  Requirements engineering 49  Problems of requirements elicitation   Stakeholders don‟t know what they really want.   Stakeholders express requirements in their own terms.   Different stakeholders may have conflicting  requirements.   Organisational and political factors may influence the  system requirements.   The requirements change during the analysis process.  New stakeholders may emerge and the business  environment change.  Chapter 3  Requirements engineering 50  Key points   The software requirements document is an agreed  statement of the system requirements. It should be  organized so that both system customers and software  developers can use it.   The requirements engineering process is an iterative  process including requirements elicitation, specification  and validation.   Requirements elicitation and analysis is an iterative  process that can be represented as a spiral of activities -  requirements discovery, requirements classification and  organization, requirements negotiation and requirements  documentation.  Chapter 3  Requirements engineering 51  Chapter 3 - Requirements Engineering  Lecture 3  52 Chapter 3  Requirements engineering  Requirements discovery   The process of gathering information about the required  and existing systems and distilling the user and system  requirements from this information.   Interaction is with system stakeholders from managers to  external regulators.   Systems normally have a range of stakeholders.  Chapter 3  Requirements engineering 53  Stakeholders in the MHC-PMS   Patients whose information is recorded in the system.   Doctors who are responsible for assessing and treating  patients.   Nurses who coordinate the consultations with doctors  and administer some treatments.  Medical receptionists who manage patients‟  appointments.   IT staff who are responsible for installing and maintaining  the system.    Chapter 3  Requirements engineering 54  Stakeholders in the MHC-PMS   A medical ethics manager who must ensure that the  system meets current ethical guidelines for patient care.   Health care managers who obtain management  information from the system.  Medical records staff who are responsible for ensuring  that system information can be maintained and  preserved, and that record keeping procedures have  been properly implemented.    Chapter 3  Requirements engineering 55  Interviewing   Formal or informal interviews with stakeholders are part  of most RE processes.   Types of interview   Closed interviews based on pre-determined list of questions   Open interviews where various issues are explored with  stakeholders.   Effective interviewing   Be open-minded, avoid pre-conceived ideas about the  requirements and are willing to listen to stakeholders.   Prompt the interviewee to get discussions going using a  springboard question, a requirements proposal, or by working  together on a prototype system.  Chapter 3  Requirements engineering 56  Interviews in practice   Normally a mix of closed and open-ended interviewing.   Interviews are good for getting an overall understanding  of what stakeholders do and how they might interact with  the system.   Interviews are not good for understanding domain  requirements   Requirements engineers cannot understand specific domain  terminology;   Some domain knowledge is so familiar that people find it hard to  articulate or think that it isn‟t worth articulating.  Chapter 3  Requirements engineering 57  Scenarios   Scenarios are real-life examples of how a system can be  used.   They should include   A description of the starting situation;   A description of the normal flow of events;   A description of what can go wrong;   Information about other concurrent activities;   A description of the state when the scenario finishes.  Chapter 3  Requirements engineering 58  Scenario for collecting medical history in MHC- PMS  59 Chapter 3  Requirements engineering  Use cases   Use-cases are a scenario based technique in the UML",
		"Source": "Chapter3.pdf\r"
	},
	{
		"Question": "which identify the actors in an interaction and which",
		"Answer": "describe the interaction itself.   A set of use cases should describe all possible  interactions with the system.   High-level graphical model supplemented by more  detailed tabular description .   Sequence diagrams may be used to add detail to use- cases by showing the sequence of event processing in  the system.  60 Chapter 3  Requirements engineering  Use cases for the MHC-PMS  61 Chapter 3  Requirements engineering  Ethnography   A social scientist spends a considerable time observing  and analysing how people actually work.   People do not have to explain or articulate their work.   Social and organisational factors of importance may be  observed.   Ethnographic studies have shown that work is usually  richer and more complex than suggested by simple  system models.  62 Chapter 3  Requirements engineering  Scope of ethnography   Requirements that are derived from the way that people  actually work rather than the way I which process  definitions suggest that they ought to work.   Requirements that are derived from cooperation and  awareness of other people‟s activities.   Awareness of what other people are doing leads to changes in  the ways in which we do things.   Ethnography is effective for understanding existing  processes but cannot identify new features that should  be added to a system.  63 Chapter 3  Requirements engineering  Focused ethnography   Developed in a project studying the air traffic control  process   Combines ethnography with prototyping   Prototype development results in unanswered questions",
		"Source": "Chapter3.pdf\r"
	},
	{
		"Question": "which focus the ethnographic analysis.",
		"Answer": " The problem with ethnography is that it studies existing  practices which may have some historical basis which is  no longer relevant.  64 Chapter 3  Requirements engineering  Ethnography and prototyping for requirements  analysis  65 Chapter 3  Requirements engineering  Requirements validation   Concerned with demonstrating that the requirements  define the system that the customer really wants.   Requirements error costs are high so validation is very  important   Fixing a requirements error after delivery may cost up to 100  times the cost of fixing an implementation error.  66 Chapter 3  Requirements engineering  Requirements checking   Validity. Does the system provide the functions which",
		"Source": "Chapter3.pdf\r"
	},
	{
		"Question": " Consistency. Are there any requirements conflicts?",
		"Answer": " Completeness. Are all functions required by the",
		"Source": "Chapter3.pdf\r"
	},
	{
		"Question": "customer included?",
		"Answer": " Realism. Can the requirements be implemented given  available budget and technology",
		"Source": "Chapter3.pdf\r"
	},
	{
		"Question": " Verifiability. Can the requirements be checked?",
		"Answer": "67 Chapter 3  Requirements engineering  Requirements validation techniques   Requirements reviews   Systematic manual analysis of the requirements.   Prototyping   Using an executable model of the system to check requirements.    Test-case generation   Developing tests for requirements to check testability.    68 Chapter 3  Requirements engineering  Requirements reviews   Regular reviews should be held while the requirements  definition is being formulated.   Both client and contractor staff should be involved in  reviews.   Reviews may be formal (with completed documents) or  informal. Good communications between developers,  customers and users can resolve problems at an early  stage.  69 Chapter 3  Requirements engineering  Review checks   Verifiability",
		"Source": "Chapter3.pdf\r"
	},
	{
		"Question": " Is the requirement realistically testable?",
		"Answer": " Comprehensibility",
		"Source": "Chapter3.pdf\r"
	},
	{
		"Question": " Is the requirement properly understood?",
		"Answer": " Traceability",
		"Source": "Chapter3.pdf\r"
	},
	{
		"Question": " Is the origin of the requirement clearly stated?",
		"Answer": " Adaptability   Can the requirement be changed without a large impact on other",
		"Source": "Chapter3.pdf\r"
	},
	{
		"Question": "requirements?",
		"Answer": "70 Chapter 3  Requirements engineering  Requirements management   Requirements management is the process of managing  changing requirements during the requirements  engineering process and system development.   New requirements emerge as a system is being  developed and after it has gone into use.   You need to keep track of individual requirements and  maintain links between dependent requirements so that  you can assess the impact of requirements changes.  You need to establish a formal process for making  change proposals and linking these to system  requirements.  71 Chapter 3  Requirements engineering  Changing requirements   The business and technical environment of the system  always changes after installation.   New hardware may be introduced, it may be necessary to  interface the system with other systems, business priorities may  change (with consequent changes in the system support  required), and new legislation and regulations may be introduced  that the system must necessarily abide by.    The people who pay for a system and the users of that  system are rarely the same people.   System customers impose requirements because of  organizational and budgetary constraints. These may conflict  with end-user requirements and, after delivery, new features may  have to be added for user support if the system is to meet its  goals.      Chapter 3  Requirements engineering 72  Changing requirements   Large systems usually have a diverse user community,  with many users having different requirements and  priorities that may be conflicting or contradictory.   The final system requirements are inevitably a compromise  between them and, with experience, it is often discovered that  the balance of support given to different users has to be  changed.  Chapter 3  Requirements engineering 73  Requirements evolution  74 Chapter 3  Requirements engineering  Requirements management planning   Establishes the level of requirements management detail  that is required.   Requirements management decisions:   Requirements identificationEach requirement must be uniquely  identified so that it can be cross-referenced with other requirements.    A change management processThis is the set of activities that  assess the impact and cost of changes. I discuss this process in  more detail in the following section.   Traceability policiesThese policies define the relationships between  each requirement and between the requirements and the system  design that should be recorded.   Tool supportTools that may be used range from specialist  requirements management systems to spreadsheets and simple  database systems.    Chapter 3  Requirements engineering 75  Requirements change management   Deciding if a requirements change should be accepted   Problem analysis and change specification  • During this stage, the problem or the change proposal is analyzed  to check that it is valid. This analysis is fed back to the change  requestor who may respond with a more specific requirements  change proposal, or decide to withdraw the request.   Change analysis and costing  • The effect of the proposed change is assessed using traceability  information and general knowledge of the system requirements.  Once this analysis is completed, a decision is made whether or not  to proceed with the requirements change.   Change implementation  • The requirements document and, where necessary, the system  design and implementation, are modified. Ideally, the document  should be organized so that changes can be easily implemented.  Chapter 3  Requirements engineering 76  Requirements change management  77 Chapter 3  Requirements engineering  Key points   You can use a range of techniques for requirements  elicitation including interviews, scenarios, use-cases and  ethnography.   Requirements validation is the process of checking the  requirements for validity, consistency, completeness,  realism and verifiability.    Business, organizational and technical changes  inevitably lead to changes to the requirements for a  software system. Requirements management is the  process of managing and controlling these changes.    Chapter 3  Requirements engineering 78",
		"Source": "Chapter3.pdf\r"
	},
	{
		"Question": "hi",
		"Answer": "hello",
		"Source": "Editorial\r"
	},
	{
		"Question": null
	}
]
}